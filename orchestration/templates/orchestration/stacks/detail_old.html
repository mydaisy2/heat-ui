{% extends 'orchestration/base.html' %}
{% load i18n sizeformat %}
{% block title %}{% trans "Stack Detail" %}{% endblock %}

{% block page_header %}
  {% include "horizon/common/_page_header.html" with title=title %}
{% endblock page_header %}

{% block heatContent %}
<div class="row-fluid">
  <div class="span12">
  {{ tab_group.render }}
  </div>
</div>
{% endblock %}

{% block heatjs %}
<script>
//Add indexOf definition for backwards-compatibility
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
    "use strict";
    if (this == null) {
      throw new TypeError();
    }
    var t = Object(this);
    var len = t.length >>> 0;

    if (len === 0) {
      return -1;
    }
    var n = 0;
    if (arguments.length > 1) {
      n = Number(arguments[1]);
      if (n != n) { // shortcut for verifying if it's NaN
        n = 0;
      } else if (n != 0 && n != Infinity && n != -Infinity) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
      }
    }
    if (n >= len) {
      return -1;
    }
    var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
    for (; k < len; k++) {
      if (k in t && t[k] === searchElement) {
        return k;
      }
    }
    return -1;
  }
}
//End indexOf


function HeatTop(el){
    // Add and remove elements on the graph object
    this.addNode = function (node) {
        nodes.push(node);
        update();
    }

    this.removeNode = function (id) {
        var i = 0;
        var n = findNode(id);
        while (i < links.length) {
            if ((links[i]['source'] == n)||(links[i]['target'] == n)) links.splice(i,1);
            else i++;
        }
        nodes.splice(findNodeIndex(id),1);
        update();
    }

    this.addLink = function (source, target) {
        links.push({"source":findNode(source),"target":findNode(target)});
        update();
    }

    var findNode = function(name) {
        for (var i in nodes) {if (nodes[i]["name"] === id) return nodes[i]};
    }

    var findNodeIndex = function(id) {
        for (var i in nodes) {if (nodes[i]["id"] === id) return i};
    }

    var width = $("#topology").width(),
        height = 500;

    var d3_data = $("#d3_data").data("d3_data");

    var force = d3.layout.force()
        .charge(-400)
        .linkDistance(150)
        .size([width, height])

    var svg = d3.select(el).append("svg")
        .attr("width", width)
        .attr("height", height);

    var graph = d3_data;

    force.nodes(graph.nodes);
    force.links(graph.links);

    var links = [];
    var nodes = [];
    var node_images = [];

    var update = function() {
        links = svg.selectAll(".link")
            .data(graph.links)
            .enter().append("line")
            .attr("class", "link")
            .style("stroke-width", function(d) { return Math.sqrt(d.value); });

        nodes = svg.selectAll(".node")
                .data(graph.nodes)
                .enter().append("g")
                .attr("class", "node")
                .attr("node_name", function(d){ return d.name })
                .call(force.drag);

        node_images = nodes.append("image")
                .attr("xlink:href", function(d) { return d.image; })
                .attr("x", function(d) { return d.image_x; })
                .attr("y", function(d) { return d.image_y; })
                .attr("width", function(d) { return d.image_size; })
                .attr("height", function(d) { return d.image_size; });

        nodes.append("text")
                .attr("dx", function(d) { return d.text_x; })
                .attr("dy", function(d) { return d.text_y; })
                .text(function(d) { return d.name; });



        force.on("tick", function() {
            links.attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });

            nodes.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
        });
        force.start();




    }
    update();

    //Build initial node dictionary
    var nodes_dict = {};
    var nodes_list = [];
    nodes.each(function(){
       d = this.__data__;
       nodes_dict[d.name] = this;
        nodes_list.push(d);
    });
    this.nodes_dict = nodes_dict;
    this.nodes_list = nodes_list;

    //Build node image dictionary
    var node_images_dict = {};
    node_images.each(function(){
       d = this.__data__;
       node_images_dict[d.name] = this;
    });
    this.node_images_dict = node_images_dict;

    //Build Links

    this.links = links;
    this.nodes = nodes;
    this.node_images = node_images;
    this.update = update;
}

//Instantiate Graph
var heattop = new HeatTop("#topology");
console.log(heattop.nodes);


//Load initial info box, and setup to change on click
var first_node = heattop.nodes_list[0];
$("#info_box").html(first_node.info_box);
var current_info = first_node.name;
heattop.nodes.on("click", function(d) {
   $("#info_box").html(d.info_box);
    current_info = d.name;
});

//On Page load, set Action In Progress
var in_progress = false;
set_in_progress(heattop.nodes);
function set_in_progress(nodes) {
  nodes.each(function() {
       var d = this.__data__;
       if (d.in_progress == true){
           in_progress = true;
           return false;
       }
  });
}

console.log(in_progress);
//If status is In Progress, start AJAX polling
if (in_progress == true){
    var d3_url = '/heat/stack/get_d3_data/'+first_node.stack_id+'/';
    console.log(d3_url);
    var ajax_poll = setInterval(function() {
        $.getJSON(d3_url, function(json) {
            console.log(json);
            var still_in_progress = false;
            json.nodes.forEach(function(d){

                //Check if node already exists
                if (heattop.nodes.indexOf(d.name) >= 0) {
                    //Node already exists, just update it
                    //Update each nodes status, info_box, and image
                    heattop.nodes[d.name].__data__.status = d.status;

                    //Status has changed, image should be updated
                    if (heattop.node_images[d.name].__data__.image != d.image){
                        heattop.node_images[d.name].__data__.image = d.image;
                        var this_image = d3.select(heattop.node_images[d.name]);
                        this_image
                                .transition()
                                .attr("x", function(d) { return d.image_x + 5; })
                                .duration(100)
                                .transition()
                                .attr("x", function(d) { return d.image_x - 5; })
                                .duration(100)
                                .transition()
                                .attr("x", function(d) { return d.image_x + 5; })
                                .duration(100)
                                .transition()
                                .attr("x", function(d) { return d.image_x - 5; })
                                .duration(100)
                                .transition()
                                .attr("xlink:href", d.image)
                                .transition()
                                .attr("x", function(d) { return d.image_x; })
                                .duration(100)
                                .ease("bounce")
                    }

                    //Status has changed, update info_box
                    heattop.nodes[d.name].__data__.info_box = d.info_box;
                    if (current_info== d.name){
                        $("#info_box").html(d.info_box);
                    }

                    heattop.update();

                } else {
                    //Node doesn't exist yet, add it to graph
                    heattop.addNode(d);

                }


                //Check if ANY nodes still in progress
                if (d.in_progress==true){
                    still_in_progress = true;
                }
            });

            //if no nodes still in progress, stop AJAX polling
            if (still_in_progress==false){
                clearInterval(ajax_poll);
            }
        });
    }, 2500)
}
</script>







{% comment %}/*
//Playing with Transitions, eventually add AJAX
images = [
    "/static/heat/img/stack.png",
    "/static/heat/img/stack_error.png",
    "/static/heat/img/load2.gif",
]

//Shaky/Nervous new image
node_image.each(function() {
   var this_image = d3.select(this);

    setInterval(function() {
        var image_url = images[Math.floor(Math.random()*images.length)];
        this_image.transition()
                .attr("x", function(d) { return d.image_x + 5; })
                .duration(100)
                .transition()
                .attr("x", function(d) { return d.image_x - 5; })
                .duration(100)
                .transition()
                .attr("x", function(d) { return d.image_x + 5; })
                .duration(100)
                .transition()
                .attr("x", function(d) { return d.image_x - 5; })
                .duration(100)
                .transition()
                .attr("xlink:href", image_url)
                .transition()
                .attr("x", function(d) { return d.image_x; })
                .duration(100)
                .ease("bounce")

    }, 5000)

});
*/
//Hide/Show Bouncy new image
/*
node_image.each(function() {
   var this_image = d3.select(this);

    setInterval(function() {
        var image_url = images[Math.floor(Math.random()*images.length)];
        console.log(image_url);
        this_image.transition()
                .attr("width", 0)
                .attr("height", 0)
                .duration(500)
                .ease("bounce")
                .transition()
                .attr("xlink:href", image_url)
                .transition()
                .attr("width",function(d) { return d.image_size; })
                .attr("height",function(d) { return d.image_size; })
                .duration(500)
                .ease("bounce")

    }, 5000)
});
*/



<script>
$(document).ready(function() {
    InitTopology();
});

//Topology code
function InitTopology() {
    /*
    function getMousePos(canvas, evt) {
        var rect = canvas.getBoundingClientRect();
        return {
          x: evt.clientX - rect.left,
          y: evt.clientY - rect.top
        };
    };
    */
    var cv_width = $("#topology_canvas").width();
    var stage = Heat.Stage({
        container: 'topology_canvas',
        width: cv_width,
        height: 500
    });

    var layer1 = new Heat.Layer({height:Heat.rowHeight});
    var stack = new Heat.Stack({
        stage: stage,
        layer: layer1,
        stack: $("#stack").data("stack")
    });

    var layer2 = new Heat.Layer({height:Heat.rowHeight,y:(layer1.getPosition().y+layer1.getHeight())});
    var resources = $("#resources").data("resources");
    var resource_group = new Heat.Group();
    $.each(resources, function() {
       //alert(this.logical_resource_id);
        resource_group.add(new Heat.Resource({
            resource:this,
            stage:stage,
            layer:layer2
        }));
    });

}
</script>
{% endcomment %}
{% endblock %}
